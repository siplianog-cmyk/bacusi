<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>Jogo de Sobrevivência JS</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <style>
    /* Estilos globais */
    html, body {
        margin: 0; padding: 0;
        width: 100vw; height: 100vh;
        overflow: hidden;
        background: #222;
        font-family: 'Segoe UI', Arial, sans-serif;
        background: linear-gradient(120deg, #2b5876 0%, #4e4376 100%);
        touch-action: none;
        color: #fff;
    }
    
    /* Telas de Menu e Início */
    .overlay-menu {
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        background: rgba(18, 18, 30, 0.95);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 200;
        text-align: center;
        backdrop-filter: blur(8px);
    }
    .overlay-menu h1 {
        font-size: 3em;
        text-shadow: 2px 2px 12px #000;
        color: #ffe066;
    }
    .overlay-menu button, .overlay-menu input[type="range"] {
        padding: 12px 36px;
        font-size: 1.5em;
        border-radius: 12px;
        border: none;
        background: #ffe066;
        color: #222;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 4px 16px rgba(0,0,0,0.4);
        transition: background 0.2s;
        margin-top: 24px;
        width: 80%;
        max-width: 300px;
    }
    .overlay-menu button:hover { background: #fff176; }
    
    /* HUD */
    #hud-panel {
      position: absolute;
      top: 12px; left: 50%; transform: translateX(-50%);
      background: rgba(40,40,60,0.85);
      border-radius: 18px;
      box-shadow: 0 4px 24px #000a;
      padding: 8px 24px 4px 24px;
      color: #fff;
      font-size: 1.1em;
      text-align: left;
      text-shadow: 1px 1px 4px #000;
      z-index: 10;
      min-width: 320px;
      max-width: 90vw;
      pointer-events: none;
      transition: opacity 0.3s;
    }
    #hud-panel.hide { opacity: 0; }
    #info { font-size: 1.1em; }
    
    /* Hotbar estilo Minecraft */
    #hotbar {
        position: absolute;
        bottom: 30px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 8px;
        z-index: 10;
        user-select: none;
    }
    .slot {
        width: 60px; height: 60px;
        background: rgba(30,30,40,0.8);
        border: 4px solid #444;
        border-radius: 12px;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.8em;
        transition: transform 0.1s, border-color 0.1s;
    }
    .slot.active {
        border-color: #ffe066;
        transform: scale(1.1);
        box-shadow: 0 0 16px rgba(255, 224, 102, 0.7);
    }
    .item-count {
        position: absolute;
        bottom: 2px; right: 4px;
        font-size: 0.8em;
        text-shadow: 1px 1px 2px #000;
    }
    
    /* Botões flutuantes para mobile */
    #action-buttons {
        position: absolute;
        right: 20px;
        bottom: 120px;
        display: none; /* Inicia oculto, mostra com media query */
        flex-direction: column;
        gap: 16px;
        z-index: 100;
    }
    #action-buttons button {
        width: 70px; height: 70px;
        border-radius: 50%;
        border: none;
        background: rgba(255,255,255,.3);
        color: #000;
        font-size: 1.8em;
        font-weight: bold;
        box-shadow: 0 4px 10px rgba(0,0,0,0.5);
    }

    #options-btn {
        position: absolute;
        top: 20px; right: 20px;
        width: 48px; height: 48px;
        background: rgba(255,255,255,0.2);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.8em;
        cursor: pointer;
        z-index: 20;
    }
    
    /* Visuais */
    .heart { color: #ff5252; font-size: 1.2em; text-shadow: 0 0 6px #fff, 0 0 2px #f00; }
    .armor { color: #b0c4de; font-size: 1.2em; text-shadow: 0 0 6px #fff, 0 0 2px #09f; }
    #pauseOverlay {
      position: absolute;
      left: 0; top: 0; width: 100vw; height: 100vh;
      background: rgba(20,20,40,0.8);
      z-index: 99;
      display: none;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-size: 3em;
      font-weight: bold;
      text-shadow: 2px 2px 12px #000;
      pointer-events: none;
    }
    canvas {
      display: block;
      position: absolute;
      left: 0; top: 0;
      width: 100vw; height: 100vh;
      background: transparent;
      border: none;
      margin: 0;
      z-index: 1;
    }

    /* Joystick */
    #joystick-area {
        position: absolute;
        bottom: 50px; left: 50px;
        width: 120px; height: 120px;
        display: none; /* Inicia oculto, mostra com media query */
        touch-action: none;
        z-index: 100;
    }
    #joystick-base {
        width: 100%; height: 100%;
        border-radius: 50%;
        background: rgba(0, 0, 0, 0.3);
        position: relative;
    }
    #joystick-stick {
        position: absolute;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        width: 60px; height: 60px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.4);
    }

    /* Media Queries para Mobile */
    @media (max-width: 768px) {
        #action-buttons { display: flex; }
        #joystick-area { display: block; }
        #hotbar { display: none; }
    }
    
    .option-label {
        font-size: 1em;
        margin-top: 16px;
    }
  </style>
</head>
<body>
  <div id="start-menu" class="overlay-menu">
      <h1>Jogo de Sobrevivência</h1>
      <button id="btn-start">Começar</button>
  </div>
  
  <div id="options-menu" class="overlay-menu" style="display: none;">
      <h1>Opções</h1>
      <p class="option-label">Volume do Jogo:</p>
      <input type="range" id="volume-slider" min="0" max="1" step="0.05" value="0.5">
      <p class="option-label">Multiplayer:</p>
      <label class="switch" style="font-size:1.5em; margin-top:16px;">
        <input type="checkbox" id="multiplayer-toggle" checked>
        <span class="slider"></span>
      </label>
      <button id="btn-resume">Continuar</button>
  </div>

  <div id="game-container">
    <div id="hud-panel">
      <div id="info">
        <span id="timer">0.0</span> s &nbsp;|&nbsp; 
        <span id="dias">Dia 1</span> &nbsp;|&nbsp;
        <span class="heart" id="vida"></span>
        <span class="armor" id="armadura"></span>
      </div>
      <div id="inv"></div>
      <div id="craft"></div>
    </div>
  
    <div id="hotbar"></div>
  
    <canvas id="game"></canvas>
    <div id="pauseOverlay">PAUSADO</div>
  
    <div id="joystick-area">
        <div id="joystick-base">
            <div id="joystick-stick"></div>
        </div>
    </div>
  
    <div id="action-buttons">
        <button id="btn-action">E</button>
        <button id="btn-create">Q</button>
    </div>
    <button id="options-btn">⚙️</button>
    <button id="restart" style="display:none;position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);z-index:20;">Recomeçar</button>
  </div>

  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" crossorigin="anonymous"></script>
  <script>

    const startMenu = document.getElementById('start-menu');
    const optionsMenu = document.getElementById('options-menu');
    const gameContainer = document.getElementById('game-container');
    const btnStart = document.getElementById('btn-start');
    const btnResume = document.getElementById('btn-resume');
    const optionsBtn = document.getElementById('options-btn');
    const btnAction = document.getElementById('btn-action');
    const btnCreate = document.getElementById('btn-create');
    const joystickArea = document.getElementById('joystick-area');
    const joystickBase = document.getElementById('joystick-base');
    const joystickStick = document.getElementById('joystick-stick');
    const volumeSlider = document.getElementById('volume-slider');
    const multiplayerToggle = document.getElementById('multiplayer-toggle');
    
    const MAPA_LARGURA = 2400;
    const MAPA_ALTURA = 1200;
    let camera = { x: 0, y: 0 };
    let florestaDesbloqueada = false;
    
    const canvas = document.getElementById('game');
    let ctx = null;

    // SONS
    const sounds = {
        click: new Audio('https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3'),
        collect: new Audio('https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3'),
        attack: new Audio('https://www.soundhelix.com/examples/mp3/SoundHelix-Song-3.mp3'),
        damage: new Audio('https://www.soundhelix.com/examples/mp3/SoundHelix-Song-4.mp3'),
    };
    
    function playSound(soundName) {
        if (sounds[soundName]) {
            sounds[soundName].volume = volumeSlider.value;
            sounds[soundName].play().catch(e => console.log("Erro ao tocar o som:", e));
        }
    }
    
    volumeSlider.addEventListener('input', (e) => {
        for (let sound in sounds) {
            sounds[sound].volume = e.target.value;
        }
    });

    function initCanvas() {
        if (!canvas) {
            console.error('Canvas element not found.');
            return;
        }
        ctx = canvas.getContext('2d');
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
    }

    function resizeCanvas() {
        if (!canvas) return;
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }

    const W = () => canvas.width;
    const H = () => canvas.height;

    const keyboard = {};

    document.addEventListener('keydown', (e) => {
      keyboard[e.key.toLowerCase()] = true;
    });

    document.addEventListener('keyup', (e) => {
      keyboard[e.key.toLowerCase()] = false;
    });

    const timerSpan = document.getElementById('timer');
    const vidaSpan = document.getElementById('vida');
    const armaduraSpan = document.getElementById('armadura');
    const diasSpan = document.getElementById('dias');
    const hudPanel = document.getElementById('hud-panel');
    const hotbarDiv = document.getElementById('hotbar');
    const pauseOverlay = document.getElementById('pauseOverlay');
    const restartBtn = document.getElementById('restart');
    
    const hotbarItens = [
      { id: 'espada', nome: 'Espada', emoji: '⚔️' },
      { id: 'picareta', nome: 'Picareta', emoji: '⛏️' },
      { id: 'maca', nome: 'Maçã', emoji: '🍎' },
      { id: 'tocha', nome: 'Tocha', emoji: '🔥' },
      { id: 'parede_madeira', nome: 'Parede Madeira', emoji: '🟫' },
      { id: 'parede_pedra', nome: 'Parede Pedra', emoji: '⬜' },
      { id: 'armadura', nome: 'Armadura', emoji: '🦺' },
      { id: 'bomba', nome: 'Bomba', emoji: '💣' },
      { id: 'madeira', nome: 'Madeira', emoji: '🌲' },
      { id: 'pedra', nome: 'Pedra', emoji: '🪨' }
    ];
    let hotbarSelecionado = 0;

    // Multiplayer
    const SOCKET_SERVER_URL = "https://bacusi-server.onrender.com";
    let socket = null;
    let selfId = null;
    const otherPlayers = {};
    let isMultiplayerEnabled = true;

    function connectSocket() {
      if (!isMultiplayerEnabled) return;
      if (socket && socket.connected) return;

      try {
        socket = io(SOCKET_SERVER_URL, { 
            transports: ['websocket'], 
            reconnectionAttempts: 5
        });

        socket.on('connect', () => { 
            selfId = socket.id;
            player.id = selfId;
            console.log('Conectado ao servidor com ID:', selfId);
            announceSelf();
        });

        socket.on('disconnect', () => {
            console.log('Desconectado do servidor.');
            // Limpa outros jogadores para evitar fantasmas
            for (const id in otherPlayers) {
                delete otherPlayers[id];
            }
        });
        
        socket.on('connect_error', (err) => {
            console.warn('Erro de conexão:', err);
        });

        socket.on('currentPlayers', (players) => {
            for (let id in players) {
              if (id !== socket.id) {
                otherPlayers[id] = players[id];
              }
            }
        });

        socket.on('newPlayer', (newPlayer) => {
          if (newPlayer.id !== selfId) {
             otherPlayers[newPlayer.id] = newPlayer;
          }
        });

        socket.on('playerDisconnected', (playerId) => {
          delete otherPlayers[playerId];
        });
        
        socket.on('state', payload => {
          if (!payload) return;
          for (const id in payload) {
              if (id !== selfId) {
                  otherPlayers[id] = payload[id];
              }
          }
        });
        
        socket.on('leave', id => { delete otherPlayers[id]; });

      } catch (e) {
        console.warn('Socket.IO não disponível. Multiplayer desativado.', e);
      }
    }
    
    function disconnectSocket() {
        if (socket) {
            socket.disconnect();
            socket = null;
        }
    }

    function announceSelf() {
        if (socket && socket.connected) {
            socket.emit('playerState', {
                id: player.id,
                x: player.x,
                y: player.y,
                vida: player.vida,
                armadura: player.armadura,
                espada: inventory.espada,
                picareta: inventory.picareta
            });
        }
    }

    let lastSentState = 0;
    const STATE_SEND_INTERVAL = 1000 / 20;

    function throttleSendState() {
      if (socket && socket.connected) {
        const now = performance.now();
        if (now - lastSentState > STATE_SEND_INTERVAL) {
          socket.emit('playerState', {
            x: player.x,
            y: player.y,
            vida: player.vida,
            armadura: inventory.armadura,
            espada: inventory.espada,
            picareta: inventory.picareta,
          });
          lastSentState = now;
        }
      }
    }

    function renderHotbar() {
      const hotbarElement = document.getElementById('hotbar');
      if (!hotbarElement) return;
      hotbarElement.innerHTML = '';
      hotbarItens.forEach((item, i) => {
        const slot = document.createElement('div');
        slot.className = `slot`;
        if (hotbarSelecionado === i) {
          slot.classList.add('active');
        }
        slot.innerHTML = `<span>${item.emoji}</span>`;
        if (inventory[item.id] !== undefined) {
          const count = document.createElement('span');
          count.className = 'item-count';
          if (typeof inventory[item.id] === 'boolean') {
            count.textContent = inventory[item.id] ? '✔️' : '';
          } else {
            count.textContent = inventory[item.id] > 0 ? inventory[item.id] : '';
          }
          slot.appendChild(count);
        }
        slot.onclick = () => { playSound('click'); hotbarSelecionado = i; renderHotbar(); };
        hotbarElement.appendChild(slot);
      });
    }

    let particles = [];
    function resetParticles() {
      particles = [];
      for (let i = 0; i < 32; i++) {
        particles.push({
          x: Math.random() * W(),
          y: Math.random() * H(),
          r: 30 + Math.random() * 60,
          dx: (Math.random() - 0.5) * 0.2,
          dy: (Math.random() - 0.5) * 0.2,
          color: `rgba(${180+Math.random()*60},${200+Math.random()*40},255,${0.08+Math.random()*0.08})`
        });
      }
    }
    resetParticles();
    window.addEventListener('resize', resetParticles);

    let player, enemies, materials, buildings, torches, apples, gems, running, startTime, elapsed, inventory, isDay, dayLength, buildMode, dias, montanhaLiberada, dayTransitionActive, lastDay, paused, mouseWorld = { x: 0, y: 0 };
    let bombs = [];
    let joystickTimeout = null;
    let joystickTouchId = null;

    function resetGame() {
      player = { 
        x: MAPA_LARGURA / 2, 
        y: MAPA_ALTURA / 2, 
        size: 40, 
        speed: 4, 
        blink: 0, 
        vida: 5, 
        armadura: false, 
        invencivel: 0, 
        id: selfId 
      };
      enemies = [];
      materials = [];
      buildings = [];
      torches = [];
      apples = [];
      gems = [];
      bombs = [];
      running = true;
      paused = false;
      startTime = performance.now();
      elapsed = 0;
      inventory = {
        madeira: 0,
        madeira_floresta: 0,
        pedra: 0,
        espada: false,
        picareta: false,
        tocha: 0,
        parede_madeira: 0,
        parede_pedra: 0,
        maca: 0,
        armadura: false,
        gema: 0,
        bomba: 0,
        sementes: 0,
        pocao: 0,
        superpicareta: false
      };
      camera.x = player.x - W() / 2; 
      camera.y = player.y - H() / 2; 
      dayTransitionActive = false;
      isDay = true;
      dayLength = 14;
      buildMode = null;
      dias = 1;
      lastDay = 1;
      montanhaLiberada = false;
      florestaDesbloqueada = false;
      camera.x = 0; camera.y = 0;
      dayTransitionActive = false;
      renderHotbar();
      updateInventory();
      updateCrafting();
      updateVida();
      resetParticles();
      spawnEnemy();
      spawnMaterials();

      restartBtn.style.display = 'none';

      announceSelf();
      requestAnimationFrame(gameLoop);
    }

    function setPause(val) {
      paused = val;
      pauseOverlay.style.display = paused ? 'flex' : 'none';
      if (!paused && !dayTransitionActive) requestAnimationFrame(gameLoop);
    }
    
    // Controles e Eventos
    document.addEventListener('keydown', e => {
      const key = e.key.toLowerCase();
      if (paused && key !== 'p') return;
      keyboard[key] = true;
      if (key === 'p') { setPause(!paused); }
      if (key >= '1' && key <= '9') { hotbarSelecionado = parseInt(key)-1; renderHotbar(); }
      if (key === '0') { hotbarSelecionado = 9; renderHotbar(); }
      if (key === ' ') attackEnemy();
      if (key === 'q' || key === 'z') { craftSelectedItem(); }
      if (key === 'e' || key === 'x') { usarHotbarAtMouse(); }
    });

    document.addEventListener('keyup', e => {
      keyboard[e.key.toLowerCase()] = false;
    });

    hotbarDiv.addEventListener('wheel', e => {
      e.preventDefault();
      playSound('click');
      if (e.deltaY > 0) hotbarSelecionado = (hotbarSelecionado + 1) % 10;
      else hotbarSelecionado = (hotbarSelecionado + 9) % 10;
      renderHotbar();
    }, {passive:false});

    canvas.addEventListener('mousemove', e=>{
      const rect = canvas.getBoundingClientRect();
      mouseWorld.x = e.clientX - rect.left + camera.x;
      mouseWorld.y = e.clientY - rect.top + camera.y;
    });

    canvas.addEventListener('mousedown', e => {
      e.preventDefault();
      if (e.button === 0) { // Botão esquerdo do mouse
        const item = hotbarItens[hotbarSelecionado].id;
        if (item === 'espada') {
          attackEnemy();
        } else if (item === 'maca') {
          usarMaca();
        } else if (item === 'picareta') {
          usePickaxeAt(mouseWorld.x, mouseWorld.y);
        } else {
          // Itens de construção, como paredes ou tochas
          buildAt(mouseWorld.x, mouseWorld.y);
        }
      }
    });
    canvas.addEventListener('contextmenu', e => e.preventDefault());
    
    // Botões mobile
    btnAction.addEventListener('touchstart', e => { e.preventDefault(); usarHotbarAtMouse(); }, {passive:false});
    btnCreate.addEventListener('touchstart', e => { e.preventDefault(); craftSelectedItem(); }, {passive:false});
    
    // Joystick
    const joystickMaxRadius = joystickBase.clientWidth / 2;
    joystickArea.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const t = e.changedTouches[0];
        joystickTouchId = t.identifier;
    }, { passive: false });

    joystickArea.addEventListener('touchmove', (e) => {
        for (let i = 0; i < e.changedTouches.length; i++) {
            const touch = e.changedTouches[i];
            if (touch.identifier === joystickTouchId) {
                const rect = joystickArea.getBoundingClientRect();
                let x = touch.clientX - rect.left - joystickMaxRadius;
                let y = touch.clientY - rect.top - joystickMaxRadius;
                const distance = Math.hypot(x, y);
                if (distance > joystickMaxRadius) {
                    const angle = Math.atan2(y, x);
                    x = Math.cos(angle) * joystickMaxRadius;
                    y = Math.sin(angle) * joystickMaxRadius;
                }
                joystickStick.style.transform = `translate(${x}px, ${y}px)`;
                
                const deadzone = 20;
                keyboard['w'] = y < -deadzone;
                keyboard['s'] = y > deadzone;
                keyboard['a'] = x < -deadzone;
                keyboard['d'] = x > deadzone;
                break;
            }
        }
    }, { passive: false });

    joystickArea.addEventListener('touchend', (e) => {
        for (let i = 0; i < e.changedTouches.length; i++) {
            if (e.changedTouches[i].identifier === joystickTouchId) {
                joystickTouchId = null;
                joystickStick.style.transform = `translate(-50%, -50%)`;
                keyboard['w'] = keyboard['s'] = keyboard['a'] = keyboard['d'] = false;
                break;
            }
        }
    });

    // Menus
    btnStart.onclick = () => {
        playSound('click');
        startMenu.style.display = 'none';
        gameContainer.style.display = 'block';
        resetGame();
        if (isMultiplayerEnabled) {
            connectSocket();
        } else {
            disconnectSocket();
        }
    };
    optionsBtn.onclick = () => {
        playSound('click');
        setPause(true);
        optionsMenu.style.display = 'flex';
        hudPanel.style.display = 'none';
    };
    btnResume.onclick = () => {
        playSound('click');
        isMultiplayerEnabled = multiplayerToggle.checked;
        if (isMultiplayerEnabled) {
            connectSocket();
        } else {
            disconnectSocket();
        }
        optionsMenu.style.display = 'none';
        hudPanel.style.display = 'block';
        setPause(false);
    };

    function updateInventory() {
        const invDiv = document.getElementById('inv');
        let txt = `<span style="font-size: 14px;">🌲 Madeira: ${inventory.madeira} | 🪨 Pedra: ${inventory.pedra} | 🍎 Maçã: ${inventory.maca} | 💣 Bomba: ${inventory.bomba}</span>`;
        invDiv.innerHTML = txt;
        renderHotbar();
    }
    
    function updateCrafting() {
      const craftDiv = document.getElementById('craft');
      let txt = `<b>Modo Construção:</b> `;
      const item = hotbarItens[hotbarSelecionado];
      if (item && item.id === buildMode) {
          txt += `${item.emoji} ${item.nome}`;
      } else {
          txt += '<span style="color:#aaa">Nenhum</span>';
      }
      craftDiv.innerHTML = txt;
    }

    function updateVida() {
      let hearts = '';
      for (let i = 0; i < Math.floor(player.vida); i++) hearts += '❤️';
      if (player.vida % 1 >= 0.5) hearts += '💔';
      vidaSpan.innerHTML = hearts;
      armaduraSpan.innerHTML = inventory.armadura ? '🦺' : '';
    }

    function craftSelectedItem() {
      playSound('click');
      const item = hotbarItens[hotbarSelecionado].id;
      if (item === 'espada' && !inventory.espada && inventory.madeira >= 3 && inventory.pedra >= 2) {
        inventory.madeira -= 3; inventory.pedra -= 2; inventory.espada = true; updateInventory();
      }
      if (item === 'picareta' && !inventory.picareta && inventory.madeira >= 2 && inventory.pedra >= 3) {
        inventory.madeira -= 2; inventory.pedra -= 3; inventory.picareta = true; updateInventory();
      }
      if (item === 'tocha' && (inventory.madeira >= 1 || inventory.madeira_floresta >= 1) && inventory.pedra >= 1) {
        if (inventory.madeira >= 1) inventory.madeira -= 1; else inventory.madeira_floresta -= 1;
        inventory.pedra -= 1; inventory.tocha += 1; updateInventory();
      }
      if (item === 'parede_madeira' && (inventory.madeira >= 2 || inventory.madeira_floresta >= 2)) {
        if (inventory.madeira >= 2) inventory.madeira -= 2; else inventory.madeira_floresta -= 2;
        inventory.parede_madeira += 1; updateInventory();
      }
      if (item === 'parede_pedra' && inventory.pedra >= 3) { inventory.pedra -= 3; inventory.parede_pedra += 1; updateInventory(); }
      if (item === 'maca' && (inventory.madeira >= 2 || inventory.madeira_floresta >= 2) && inventory.pedra >= 1) {
        if (inventory.madeira >= 2) inventory.madeira -= 2; else inventory.madeira_floresta -= 2;
        inventory.pedra -= 1; inventory.maca += 1; updateInventory();
      }
      if (item === 'armadura' && !inventory.armadura && inventory.pedra >= 4 && (inventory.madeira >= 2 || inventory.madeira_floresta >= 2)) {
        inventory.pedra -= 4; if (inventory.madeira >= 2) inventory.madeira -= 2; else inventory.madeira_floresta -= 2;
        inventory.armadura = true; player.armadura = true; updateInventory(); updateVida();
      }
      if (item === 'gema' && inventory.gema >= 5) {
        inventory.gema -= 5; inventory.superpicareta = true; updateInventory();
        alert("Você criou a Super Picareta! Selecione e use no mapa para destruir instantaneamente.");
      }
      if (item === 'bomba' && inventory.pedra >= 2 && inventory.madeira >= 2) {
        inventory.pedra -= 2; inventory.madeira -= 2; inventory.bomba++; updateInventory();
      }
    }

    function usarHotbarAtMouse() {
      const item = hotbarItens[hotbarSelecionado].id;
      if (item === 'espada') {
        attackEnemy();
      } else if (item === 'maca') {
        usarMaca();
      } else if (item === 'tocha' || item === 'parede_madeira' || item === 'parede_pedra' || item === 'bomba') {
        buildMode = item;
        updateCrafting();
      } else if (item === 'picareta') {
        usePickaxeAt(mouseWorld.x, mouseWorld.y);
      }
    }
    
    function usarMaca() {
      if (inventory.maca > 0 && player.vida < 5) {
        playSound('collect');
        inventory.maca--; player.vida = Math.min(5, player.vida + 2); updateInventory(); updateVida();
      }
    }
    
    function attackEnemy() {
      if (!inventory.espada) return;
      playSound('attack');
      for (let e of enemies) {
        if (!e.alive) continue;
        const dx = player.x + player.size/2 - (e.x + e.size/2);
        const dy = player.y + player.size/2 - (e.y + e.size/2);
        const dist = Math.hypot(dx, dy);
        if (dist < 54) { e.vida--; if (e.vida <= 0) e.alive = false; return; }
      }
    }
    
    function usePickaxeAt(x, y) {
      if (!inventory.picareta && !inventory.superpicareta) return;
      playSound('attack');
      const radius = inventory.superpicareta ? 120 : 48;
      for (let i = materials.length-1; i >= 0; i--) {
        const m = materials[i];
        const dx = (m.x + m.size/2) - x;
        const dy = (m.y + m.size/2) - y;
        if (Math.hypot(dx,dy) <= radius) {
          if (m.type === 'madeira') inventory.madeira++;
          else if (m.type === 'pedra') inventory.pedra++;
          else if (m.type === 'madeira_floresta') inventory.madeira_floresta++;
          m.x = -100;
        }
      }
      for (let i = buildings.length-1; i >= 0; i--) {
        const b = buildings[i];
        const bx = b.x + b.size/2, by = b.y + b.size/2;
        if (Math.hypot(bx-x, by-y) <= radius) {
          if (b.type === 'parede_madeira') inventory.madeira += 1;
          if (b.type === 'parede_pedra') inventory.pedra += 2;
          buildings.splice(i,1);
        }
      }
      updateInventory();
      renderHotbar();
    }
    
    function buildAt(x, y) {
      if (!buildMode) return;
      
      let item = hotbarItens[hotbarSelecionado].id;
      if (item === 'tocha' && inventory.tocha > 0) {
        playSound('click');
        torches.push({ x: x-12, y: y-12, size: 24 }); inventory.tocha--; updateInventory();
        buildMode = null;
      } else if (item === 'parede_madeira' && inventory.parede_madeira > 0) {
        playSound('click');
        buildings.push({ x: x-20, y: y-20, size: 40, type: 'parede_madeira' });
        inventory.parede_madeira--; updateInventory();
        buildMode = null;
      } else if (item === 'parede_pedra' && inventory.parede_pedra > 0) {
        playSound('click');
        buildings.push({ x: x-20, y: y-20, size: 40, type: 'parede_pedra' });
        inventory.parede_pedra--; updateInventory();
        buildMode = null;
      } else if (item === 'bomba' && inventory.bomba > 0) {
        playSound('click');
        bombs.push({ x: x-12, y: y-12, size: 24, timer: 900 }); inventory.bomba--; updateInventory();
        buildMode = null;
      } else {
        // Nada para construir ou item selecionado errado.
        buildMode = null;
      }
      updateCrafting();
    }
    
    function spawnEnemy() {
      const edge = Math.floor(Math.random() * 4);
      let x, y;
      if (edge === 0) { x = 0; y = Math.random() * MAPA_ALTURA; }
      else if (edge === 1) { x = MAPA_LARGURA; y = Math.random() * MAPA_ALTURA; }
      else if (edge === 2) { x = Math.random() * MAPA_LARGURA; y = 0; }
      else { x = Math.random() * MAPA_LARGURA; y = MAPA_ALTURA; }
      let tipo = 'normal', cor = 'red', vida = 1, speed = 1.2 + Math.random(), dano = 1;
      if (dias >= 10 && Math.random() < 0.2) { tipo = 'rapido'; cor = '#ff9800'; speed = 2.5 + Math.random(); }
      if (dias >= 25 && Math.random() < 0.15) { tipo = 'tanque'; cor = '#607d8b'; vida = 3; speed = 0.7 + Math.random()*0.5; dano = 2; }
      if (dias >= 100 && Math.random() < 0.1) { tipo = 'fantasma'; cor = '#b39ddb'; vida = 2; speed = 1.7 + Math.random(); dano = 2; }
      if (dias >= 200 && Math.random() < 0.07) { tipo = 'explosivo'; cor = '#fff176'; vida = 1; speed = 1.3 + Math.random(); dano = 3; }
      enemies.push({ x, y, size: 36, speed, alive: true, mood: Math.random(), tipo, cor, vida, dano, explodindo: false });
    }
    
    function spawnMaterials() {
      materials = [];
      for (let i = 0; i < 12; i++) {
        materials.push({ x: Math.random() * (MAPA_LARGURA-60), y: Math.random() * (MAPA_ALTURA-60), size: 32, type: 'madeira' });
      }
      for (let i = 0; i < 9; i++) {
        materials.push({ x: Math.random() * (MAPA_LARGURA-60), y: Math.random() * (MAPA_ALTURA-60), size: 28, type: 'pedra' });
      }
      if (florestaDesbloqueada) {
        for (let i = 0; i < 20; i++) {
          materials.push({
            x: W() + 80 + Math.random() * (MAPA_LARGURA - W() - 160),
            y: 60 + Math.random() * (MAPA_ALTURA - 120),
            size: 36,
            type: Math.random() < 0.85 ? 'madeira_floresta' : 'madeira'
          });
        }
      }
      apples = Math.random() < 0.6 ? [{ x: Math.random() * (MAPA_LARGURA-60), y: Math.random() * (MAPA_ALTURA-60), size: 24, collected: false }] : [];
      gems = (montanhaLiberada && Math.random() < 0.6) ? [{ x: MAPA_LARGURA - 200 + Math.random() * 160, y: 80 + Math.random() * (H()-160), size: 26, collected: false }] : [];
    }
    
    function movePlayer() {
      let vel = player.speed;
      let moved = false;
      if (florestaDesbloqueada && player.x > W()-100) vel = player.speed * 0.55;
      if (keyboard['arrowup'] || keyboard['w']) { player.y -= vel; moved = true; }
      if (keyboard['arrowdown'] || keyboard['s']) { player.y += vel; moved = true; }
      if (keyboard['arrowleft'] || keyboard['a']) { player.x -= vel; moved = true; }
      if (keyboard['arrowright'] || keyboard['d']) { player.x += vel; moved = true; }
      if (!montanhaLiberada && player.x > MAPA_LARGURA - 200) player.x = MAPA_LARGURA - 200;
      if (player.x < 0) player.x = 0;
      if (player.x > MAPA_LARGURA - player.size) player.x = MAPA_LARGURA - player.size;
      if (player.y < 0) player.y = 0;
      if (player.y > MAPA_ALTURA - player.size) player.y = MAPA_ALTURA - player.size;
      return moved;
    }
    
    function updateCamera() {
      if (florestaDesbloqueada && player.x > W()-100) {
        camera.x = Math.max(0, Math.min(player.x - W()/2 + player.size/2, MAPA_LARGURA - W()));
      } else {
        camera.x = 0;
      }
      camera.y = Math.max(0, Math.min(player.y - H()/2 + player.size/2, MAPA_ALTURA - H()));
    }
    
    function moveEnemies() {
      for (let e of enemies) {
        if (!e.alive) continue;
        let blocked = false;
        if (e.tipo !== 'fantasma') {
          for (let b of buildings) {
            if (e.x < b.x + b.size && e.x + e.size > b.x && e.y < b.y + b.size && e.y + e.size > b.y) { blocked = true; break; }
          }
        }
        if (blocked) continue;
        const dx = player.x - e.x;
        const dy = player.y - e.y;
        const dist = Math.hypot(dx, dy) || 1;
        e.x += (dx / dist) * e.speed;
        e.y += (dy / dist) * e.speed;
      }
    }
    
    function checkCollision() {
      for (let m of materials) {
        if (m.x < 0) continue;
        if (player.x < m.x + m.size && player.x + player.size > m.x && player.y < m.y + m.size && player.y + player.size > m.y) {
          playSound('collect');
          if (m.type === 'madeira') inventory.madeira++;
          if (m.type === 'pedra') inventory.pedra++;
          if (m.type === 'madeira_floresta') inventory.madeira_floresta++;
          m.x = -100;
          updateInventory();
        }
      }
      for (let a of apples) {
        if (!a.collected && player.x < a.x + a.size && player.x + player.size > a.x && player.y < a.y + a.size && player.y + player.size > a.y) {
          playSound('collect');
          inventory.maca++; a.collected = true; updateInventory();
        }
      }
      for (let g of gems) {
        if (!g.collected && player.x < g.x + g.size && player.x + player.size > g.x && player.y < g.y + g.size && player.y + player.size > g.y) {
          playSound('collect');
          inventory.gema++; g.collected = true; updateInventory();
        }
      }
      for (let e of enemies) {
        if (!e.alive) continue;
        if (player.x < e.x + e.size && player.x + player.size > e.x && player.y < e.y + e.size && player.y + player.size > e.y) {
          if (player.invencivel > 0) continue;
          playSound('damage');
          if (e.tipo === 'explosivo' && !e.explodindo) {
            e.explodindo = true;
            setTimeout(()=>{
              if (!running) return;
              player.vida -= e.dano;
              updateVida();
              e.alive = false;
              if (player.vida <= 0) { running = false; restartBtn.style.display = 'inline'; }
            }, 300);
          } else {
            if (inventory.armadura) player.vida -= e.dano*0.5;
            else player.vida -= e.dano;
            player.invencivel = 40;
            updateVida();
            if (player.vida <= 0) { running = false; restartBtn.style.display = 'inline'; }
          }
        }
      }
    }
    
    function drawBackground(now) {
      if (!ctx) return;
      let t = (now/2000)%1;
      let grad = ctx.createLinearGradient(0, 0, W(), H());
      grad.addColorStop(0, isDay ? "#b6e07a" : "#2b3c5e");
      grad.addColorStop(0.5+t/2, isDay ? "#6bbf3c" : "#1a1e3e");
      grad.addColorStop(1, isDay ? "#a2e0e6" : "#223c16");
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, W(), H());
      for (let p of particles) {
        ctx.save();
        ctx.globalAlpha = 1;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r, 0, 2*Math.PI);
        ctx.fillStyle = p.color;
        ctx.fill();
        ctx.restore();
        p.x += p.dx; p.y += p.dy;
        if (p.x < -p.r) p.x = W() + p.r;
        if (p.x > W() + p.r) p.x = -p.r;
        if (p.y < -p.r) p.y = H() + p.r;
        if (p.y > H() + p.r) p.y = -p.r;
      }
    }
    
    function drawWorld(now) {
      if (!ctx) return;
      if (montanhaLiberada) {
        ctx.save();
        ctx.globalAlpha = 0.9;
        ctx.fillStyle = "#b0bec5";
        ctx.beginPath();
        ctx.moveTo(MAPA_LARGURA-200, MAPA_ALTURA);
        ctx.lineTo(MAPA_LARGURA-100, MAPA_ALTURA/2);
        ctx.lineTo(MAPA_LARGURA, MAPA_ALTURA/2+100);
        ctx.lineTo(MAPA_LARGURA, MAPA_ALTURA);
        ctx.closePath();
        ctx.fill();
        ctx.globalAlpha = 1;
        ctx.restore();
        ctx.save();
        ctx.fillStyle = "#fff";
        ctx.globalAlpha = 0.3;
        ctx.beginPath();
        ctx.moveTo(MAPA_LARGURA-100, MAPA_ALTURA/2);
        ctx.lineTo(MAPA_LARGURA-60, MAPA_ALTURA/2+40);
        ctx.lineTo(MAPA_LARGURA-20, MAPA_ALTURA/2+20);
        ctx.lineTo(MAPA_LARGURA, MAPA_ALTURA/2+100);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
    
      for (let m of materials) {
        if (m.x < 0) continue;
        if (m.type === 'madeira' || m.type === 'madeira_floresta') {
          ctx.save();
          ctx.shadowColor = "#5a2d0c";
          ctx.shadowBlur = 10;
          ctx.fillStyle = m.type === 'madeira' ? "#8B4513" : "#6A4E1A";
          ctx.beginPath();
          ctx.arc(m.x+m.size/2, m.y+m.size/2, m.size/2, 0, 2*Math.PI);
          ctx.fill();
          ctx.shadowBlur = 0;
          ctx.strokeStyle = "#deb887";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(m.x+m.size/2, m.y+m.size/2, m.size/4, 0, 2*Math.PI);
          ctx.stroke();
          ctx.fillStyle = m.type === 'madeira' ? "#4caf50" : "#2e7d32";
          ctx.beginPath();
          ctx.arc(m.x+m.size/2+8, m.y+m.size/2-10, 7, 0, 2*Math.PI);
          ctx.fill();
          ctx.restore();
        } else {
          ctx.save();
          ctx.shadowColor = "#fff";
          ctx.shadowBlur = 8;
          ctx.fillStyle = "#bcd";
          ctx.beginPath();
          ctx.ellipse(m.x+m.size/2, m.y+m.size/2, m.size/2, m.size/2.5, 0.3, 0, 2*Math.PI);
          ctx.fill();
          ctx.shadowBlur = 0;
          ctx.fillStyle = "#fff8";
          ctx.beginPath();
          ctx.arc(m.x+m.size/2+5, m.y+m.size/2-5, 5, 0, 2*Math.PI);
          ctx.fill();
          ctx.restore();
        }
      }
    
      for (let a of apples) {
        if (a.collected) continue;
        ctx.save();
        ctx.shadowColor = "#f00";
        ctx.shadowBlur = 10;
        ctx.fillStyle = "#e53935";
        ctx.beginPath();
        ctx.arc(a.x+a.size/2, a.y+a.size/2, a.size/2, 0, 2*Math.PI);
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.fillStyle = "#fff8";
        ctx.beginPath();
        ctx.arc(a.x+a.size/2+3, a.y+a.size/2-5, 4, 0, 2*Math.PI);
        ctx.fill();
        ctx.strokeStyle = "#795548";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(a.x+a.size/2, a.y+a.size/2-8);
        ctx.lineTo(a.x+a.size/2, a.y+a.size/2-14);
        ctx.stroke();
        ctx.restore();
      }
    
      for (let g of gems) {
        if (g.collected) continue;
        ctx.save();
        ctx.shadowColor = "#00e";
        ctx.shadowBlur = 16;
        ctx.fillStyle = "#00e6ff";
        ctx.beginPath();
        ctx.moveTo(g.x+g.size/2, g.y);
        ctx.lineTo(g.x+g.size, g.y+g.size/2);
        ctx.lineTo(g.x+g.size/2, g.y+g.size);
        ctx.lineTo(g.x, g.y+g.size/2);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
    
      for (let b of buildings) {
        if (b.type === 'parede_madeira') {
          ctx.save();
          ctx.shadowColor = "#deb887";
          ctx.shadowBlur = 8;
          ctx.fillStyle = "#deb887";
          ctx.strokeStyle = "#8B4513";
          ctx.lineWidth = 3;
          ctx.fillRect(b.x, b.y, b.size, b.size);
          ctx.strokeRect(b.x, b.y, b.size, b.size);
          ctx.beginPath();
          ctx.moveTo(b.x+8, b.y+b.size-8); ctx.lineTo(b.x+b.size-8, b.y+8);
          ctx.stroke();
          ctx.restore();
        } else {
          ctx.save();
          ctx.shadowColor = "#bbb";
          ctx.shadowBlur = 8;
          ctx.fillStyle = "#bbb";
          ctx.strokeStyle = "#444";
          ctx.lineWidth = 3;
          ctx.fillRect(b.x, b.y, b.size, b.size);
          ctx.strokeRect(b.x, b.y, b.size, b.size);
          ctx.beginPath();
          ctx.arc(b.x+b.size/2, b.y+b.size/2, 10, 0, 2*Math.PI);
          ctx.stroke();
          ctx.restore();
        }
      }
    
      for (let t of torches) {
        ctx.save();
        ctx.shadowColor = "#ff0";
        ctx.shadowBlur = 24;
        ctx.fillStyle = "#ff0";
        ctx.beginPath();
        ctx.arc(t.x+12, t.y+12, 12, 0, 2*Math.PI);
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.strokeStyle = "#b8860b";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(t.x+12, t.y+12);
        ctx.lineTo(t.x+12, t.y+26);
        ctx.stroke();
        ctx.restore();
      }
    
      for (let b of bombs) {
        ctx.save();
        ctx.fillStyle = '#222';
        ctx.fillRect(b.x, b.y, b.size, b.size);
        ctx.fillStyle = '#f33';
        ctx.fillRect(b.x+6, b.y+6, b.size-12, 6);
        ctx.restore();
      }
    
      if (player) {
          drawPlayerEntity(player, true);
      }
    
      for (const [id, p] of Object.entries(otherPlayers)) {
        if (!p) continue;
        drawPlayerEntity(p, false);
      }
    
      for (let e of enemies) {
        if (!e.alive) continue;
        ctx.save();
        ctx.translate(e.x+e.size/2, e.y+e.size/2);
        ctx.shadowColor = e.cor;
        ctx.shadowBlur = 16;
        ctx.fillStyle = e.cor;
        ctx.beginPath();
        ctx.arc(0, 0, e.size/2, 0, 2*Math.PI);
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.ellipse(-7, -6, 5, 4, 0, 0, 2*Math.PI);
        ctx.ellipse(7, -6, 5, 4, 0, 0, 2*Math.PI);
        ctx.fill();
        ctx.fillStyle = "#900";
        ctx.beginPath();
        ctx.ellipse(-7, -6, 2, 2, 0, 0, 2*Math.PI);
        ctx.ellipse(7, -6, 2, 2, 0, 0, 2*Math.PI);
        ctx.fill();
        ctx.strokeStyle = "#900";
        ctx.lineWidth = 2;
        ctx.beginPath();
        if (e.tipo === 'tanque') ctx.arc(0, 15, 8, Math.PI, 2*Math.PI);
        else if (e.tipo === 'rapido') ctx.arc(0, 7, 8, 0, Math.PI);
        else if (e.tipo === 'explosivo') ctx.arc(0, 0, 12, 0, 2*Math.PI);
        else ctx.arc(0, 7, 8, 0.2, Math.PI-0.2);
        ctx.stroke();
        ctx.restore();
      }
    }
    
    function drawPlayerEntity(ent, isSelf) {
      if (!ctx || !ent) return;
      ctx.save();
      ctx.translate(ent.x+ent.size/2, ent.y+ent.size/2);
      ctx.shadowColor = isSelf ? "#00bfff" : "#00ff95";
      ctx.shadowBlur = 18;
      ctx.globalAlpha = ent.invencivel > 0 ? 0.5 : 1;
      ctx.fillStyle = isSelf ? 'deepskyblue' : '#36e3a0';
      ctx.beginPath();
      ctx.arc(0, 0, ent.size/2, 0, 2*Math.PI);
      ctx.fill();
      ctx.shadowBlur = 0;
      if (ent.armadura) {
        ctx.strokeStyle = "#b0c4de";
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.arc(0, 0, ent.size/2-2, Math.PI*0.15, Math.PI*0.85);
        ctx.stroke();
      }
      let blink = Math.abs(Math.sin(Date.now()/600 + ent.x/50));
      ctx.fillStyle = "#fff";
      ctx.beginPath();
      ctx.ellipse(-9, -7, 6, 5*blink, 0, 0, 2*Math.PI);
      ctx.ellipse(9, -7, 6, 5*blink, 0, 0, 2*Math.PI);
      ctx.fill();
      ctx.fillStyle = "#222";
      ctx.beginPath();
      ctx.ellipse(-9, -7, 2, 2*blink, 0, 0, 2*Math.PI);
      ctx.ellipse(9, -7, 2, 2*blink, 0, 0, 2*Math.PI);
      ctx.fill();
      ctx.strokeStyle = "#222";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(0, 7, 10, 0.2, Math.PI-0.2);
      ctx.stroke();
      ctx.restore();
    
      if (ent.espada) {
        ctx.save();
        ctx.translate(ent.x+ent.size, ent.y+ent.size/2);
        ctx.rotate(-0.2);
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, -5, 22, 10);
        ctx.strokeStyle = "#aaa";
        ctx.lineWidth = 2;
        ctx.strokeRect(0, -5, 22, 10);
        ctx.restore();
      }
      if (ent.picareta) {
        ctx.save();
        ctx.translate(ent.x-10, ent.y+ent.size/2);
        ctx.fillStyle = '#888';
        ctx.fillRect(0, -4, 16, 8);
        ctx.fillRect(7, -12, 5, 18);
        ctx.restore();
      }
      if (ent.superpicareta) {
        ctx.save();
        ctx.translate(ent.x-18, ent.y+ent.size/2-18);
        ctx.fillStyle = '#0ff';
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0,0); ctx.lineTo(30,10); ctx.lineTo(10,30); ctx.closePath();
        ctx.fill();
        ctx.stroke();
        ctx.restore();
      }
    }
    
    function gameLoop(now) {
      if (!ctx) {
        console.warn("Canvas context not initialized. Retrying...");
        setTimeout(() => requestAnimationFrame(gameLoop), 100);
        return;
      }

      if (!startTime) startTime = now;
      if (running && !paused) {
        elapsed = (now - startTime) / 1000;
        timerSpan.textContent = elapsed.toFixed(1);
        dias = Math.floor(elapsed / (dayLength*2)) + 1;
        if (dias !== lastDay) { lastDay = dias; }
        diasSpan.textContent = "Dia " + dias;
        if (!florestaDesbloqueada && dias >= 15) {
          florestaDesbloqueada = true;
          spawnMaterials();
        }
        if (!montanhaLiberada && dias >= 1000) montanhaLiberada = true;
        isDay = Math.floor(elapsed / dayLength) % 2 === 0;
        
        let moved = movePlayer();
        updateCamera();
        moveEnemies();
        checkCollision();
        
        if (moved) {
          throttleSendState();
        }
    
        for (let i = bombs.length-1; i >= 0; i--) {
          const b = bombs[i];
          b.timer -= (1000/60);
          if (b.timer <= 0) {
            const ex = b.x + b.size/2, ey = b.y + b.size/2;
            const r = 120;
            for (let j = enemies.length-1; j >= 0; j--) {
              const e = enemies[j];
              if (!e.alive) continue;
              if (Math.hypot(e.x+e.size/2-ex, e.y+e.size/2-ey) <= r) { e.alive = false; }
            }
            for (let j = materials.length-1; j >= 0; j--) {
              const m = materials[j];
              if (Math.hypot(m.x+m.size/2-ex, m.y+m.size/2-ey) <= r) m.x = -100;
            }
            for (let j = buildings.length-1; j >= 0; j--) {
              const bld = buildings[j];
              if (Math.hypot(bld.x+bld.size/2-ex, bld.y+bld.size/2-ey) <= r) buildings.splice(j,1);
            }
            if (Math.hypot(player.x+player.size/2-ex, player.y+player.size/2-ey) <= r) {
              player.vida -= 2; updateVida();
              if (player.vida <= 0) { running = false; restartBtn.style.display = 'inline'; }
            }
            bombs.splice(i,1);
          }
        }
    
        drawBackground(now);
        
        ctx.save();
        ctx.translate(-camera.x, -camera.y);
        drawWorld(now);
        ctx.restore();
    
        if (player.invencivel > 0) player.invencivel--;
        if (!isDay && Math.floor(elapsed * 10) % 15 === 0 && enemies.length < Math.floor(elapsed / 2) + 2) spawnEnemy();
        if (Math.floor(elapsed) % 14 === 0 && Math.floor(elapsed) !== 0 && Math.floor(elapsed * 10) % 10 === 0) spawnMaterials();
    
        requestAnimationFrame(gameLoop);
      } else if (!running) {
        timerSpan.textContent = elapsed.toFixed(1);
        ctx.save();
        ctx.globalAlpha = 0.85;
        ctx.fillStyle = '#222b';
        ctx.fillRect(W()/2-180, H()/2-80, 360, 160);
        ctx.globalAlpha = 1;
        ctx.fillStyle = 'white';
        ctx.font = '38px Arial';
        ctx.textAlign = "center";
        ctx.fillText('Game Over!', W()/2, H()/2-10);
        ctx.font = '24px Arial';
        ctx.fillText('Tempo: ' + elapsed.toFixed(1) + ' s', W()/2, H()/2+30);
        ctx.restore();
      }
      if (paused) {
        drawBackground(now);
        ctx.save();
        ctx.translate(-camera.x, -camera.y);
        drawWorld(now);
        ctx.restore();
        requestAnimationFrame(gameLoop);
      }
    }

    window.onload = () => { 
      gameContainer.style.display = 'none';
      startMenu.style.display = 'flex';
      initCanvas();
    };
    restartBtn.onclick = resetGame;
  </script>
</body>
</html>